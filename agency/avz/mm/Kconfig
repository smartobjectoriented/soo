
comment "Processor Type"

config CPU_32
	bool
	default y

config CPU_CP15
	bool
	help
	  Processor has the CP15 register.
	  
config CPU_CP15_MMU
	bool
	select CPU_CP15
	help
	  Processor has the CP15 register, which has MMU related registers.

config CPU_CP15_MPU
	bool
	select CPU_CP15
	help
	  Processor has the CP15 register, which has MPU related registers.

# Select CPU types depending on the architecture selected.  This selects
# which CPUs we support in the kernel image, and the compiler instruction
# optimiser behaviour.

config PL310_ERRATA_753970
	bool "PL310 errata: cache sync operation may be faulty"
	help
	  This option enables the workaround for the 753970 PL310 (r3p0) erratum.

	  Under some condition the effect of cache sync operation on
	  the store buffer still remains when the operation completes.
	  This means that the store buffer is always asked to drain and
	  this prevents it from merging any further writes. The workaround
	  is to replace the normal offset of cache sync operation (0x730)
	  by another offset targeting an unmapped PL310 register 0x740.
	  This has the same effect as the cache sync operation: store buffer
	  drain and waiting for all buffers empty.
        

# ARMv7
config CPU_V7
	bool "Support ARM V7 processor" if ARCH_INTEGRATOR || MACH_REALVIEW_EB || ARCH_MSM_SCORPION || ARCH_VERSATILE_PB || ARCH_ZYNQ
	select CPU_32v7
	select CPU_ABRT_EV7
	select CPU_PABRT_IFAR
	select CPU_CACHE_V7
	select CPU_CACHE_VIPT
	select CPU_CP15_MMU
	select CPU_HAS_ASID 
	select CPU_COPY_V6 
	select CPU_TLB_V7 

config CPU_32v7
	bool

# The abort model
 
config CPU_ABRT_EV7
	bool

config CPU_PABRT_IFAR
	bool
 

# The cache model
 
config CPU_CACHE_V7
	bool

config CPU_CACHE_VIVT
	bool

config CPU_CACHE_VIPT
	bool
 
# The copy-page model

config CPU_TLB_V7
	bool

config VERIFY_PERMISSION_FAULT
	bool

 
config CPU_HAS_ASID
	bool
	help
	  This indicates whether the CPU has the ASID register; used to
	  tag TLB and possibly cache entries.

#
# CPU supports 36-bit I/O
#
config IO_36
	bool

comment "Processor Features"

config ARM_THUMB
	bool "Support Thumb user binaries"
	depends on CPU_ARM720T || CPU_ARM740T || CPU_ARM920T || CPU_ARM922T || CPU_ARM925T || CPU_ARM926T || CPU_ARM940T || CPU_ARM946E || CPU_ARM1020 || CPU_ARM1020E || CPU_ARM1022 || CPU_ARM1026 || CPU_XSCALE || CPU_XSC3 || CPU_MOHAWK || CPU_V6 || CPU_V7 || CPU_FEROCEON
	default y
	help
	  Say Y if you want to include kernel support for running user space
	  Thumb binaries.

	  The Thumb instruction set is a compressed form of the standard ARM
	  instruction set resulting in smaller binaries at the expense of
	  slightly less efficient code.

	  If you don't know what this all is, saying Y is a safe choice.

config ARM_THUMBEE
	bool "Enable ThumbEE CPU extension"
	depends on CPU_V7
	help
	  Say Y here if you have a CPU with the ThumbEE extension and code to
	  make use of it. Say N for code that can run on CPUs without ThumbEE.

config SWP_EMULATE
        bool "Emulate SWP/SWPB instructions"
        depends on !CPU_USE_DOMAINS && CPU_V7
        #select HAVE_PROC_CPU if PROC_FS
        default y if SMP
        help
          ARMv6 architecture deprecates use of the SWP/SWPB instructions.
          ARMv7 multiprocessing extensions introduce the ability to disable
          these instructions, triggering an undefined instruction exception
          when executed. Say Y here to enable software emulation of these
          instructions for userspace (not kernel) using LDREX/STREX.
          Also creates /proc/cpu/swp_emulation for statistics.

          In some older versions of glibc [<=2.8] SWP is used during futex
          trylock() operations with the assumption that the code will not
          be preempted. This invalid assumption may be more likely to fail
          with SWP emulation enabled, leading to deadlock of the user
          application.

          NOTE: when accessing uncached shared regions, LDREX/STREX rely
          on an external transaction monitoring block called a global
          monitor to maintain update atomicity. If your system does not
          implement a global monitor, this option can cause programs that
          perform SWP operations to uncached memory to deadlock.

          If unsure, say Y.


config CPU_BIG_ENDIAN
	bool "Build big-endian kernel"
	depends on ARCH_SUPPORTS_BIG_ENDIAN
	help
	  Say Y if you plan on running a kernel in big-endian mode.
	  Note that your board must be properly built and your board
	  port must properly enable any big-endian related features
	  of your chipset/board/processor.

config CPU_ICACHE_DISABLE
	bool "Disable I-Cache"
	depends on CPU_ARM920T || CPU_ARM922T || CPU_ARM925T || CPU_ARM926T || CPU_ARM1020 || CPU_V6
	help
	  Say Y here to disable the processor instruction cache. Unless
	  you have a reason not to or are unsure, say N.

config CPU_DCACHE_DISABLE
	bool "Disable D-Cache"
	depends on CPU_ARM920T || CPU_ARM922T || CPU_ARM925T || CPU_ARM926T || CPU_ARM1020 || CPU_V6
	help
	  Say Y here to disable the processor data cache. Unless
	  you have a reason not to or are unsure, say N.

config CPU_DCACHE_WRITETHROUGH
	bool "Force write through D-cache"
	depends on (CPU_ARM920T || CPU_ARM922T || CPU_ARM925T || CPU_ARM926T || CPU_ARM1020 || CPU_V6) && !CPU_DCACHE_DISABLE
	default y if CPU_ARM925T
	help
	  Say Y here to use the data cache in writethrough mode. Unless you
	  specifically require this or are unsure, say N.

config CPU_CACHE_ROUND_ROBIN
	bool "Round robin I and D cache replacement algorithm"
	depends on (CPU_ARM926T || CPU_ARM1020) && (!CPU_ICACHE_DISABLE || !CPU_DCACHE_DISABLE)
	help
	  Say Y here to use the predictable round-robin cache replacement
	  policy.  Unless you specifically require this or are unsure, say N.

config CPU_BPREDICT_DISABLE
	bool "Disable branch prediction"
	depends on CPU_ARM1020 || CPU_V6
	help
	  Say Y here to disable branch prediction.  If unsure, say N.

config TLS_REG_EMUL
	bool
	help
	  An SMP system using a pre-ARMv6 processor (there are apparently
	  a few prototypes like that in existence) and therefore access to
	  that required register must be emulated.

config HAS_TLS_REG
	bool
	depends on !TLS_REG_EMUL
	default y if SMP # || CPU_32v7
	help
	  This selects support for the CP15 thread register.
	  It is defined to be available on some ARMv6 processors (including
	  all SMP capable ARMv6's) or later processors.  User space may
	  assume directly accessing that register and always obtain the
	  expected value only on ARMv7 and above.

config NEEDS_SYSCALL_FOR_CMPXCHG
	bool
	help
	  SMP on a pre-ARMv6 processor?  Well OK then.
	  Forget about fast user space cmpxchg support.
	  It is just not possible.

config MIGHT_HAVE_CACHE_L2X0
	bool
	help
	  This option should be selected by machines which have a L2x0
	  or PL310 cache controller, but where its use is optional.

	  The only effect of this option is to make CACHE_L2X0 and
	  related options available to the user for configuration.

	  Boards or SoCs which always require the cache controller
	  support to be present should select CACHE_L2X0 directly
	  instead of this option, thus preventing the user from
	  inadvertently configuring a broken kernel.
	  	
 
