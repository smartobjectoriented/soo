/*
 * Copyright (C) 2022 Mattia Gallacchi <mattia.gallacchi@heig-vd.ch>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 *
 */

#include <rapidjson/document.h>
#include <iostream>
#include <stdexcept>
#include <algorithm>
#include <unistd.h>
#include <fcntl.h>
#include <csignal>
#include <cerrno>
#include <string>
#include <cstring>
#include <cstdio>
#include <sstream>

#include "ledcontrol.h"

#if 0
#define DEBUG
#endif

sig_atomic_t end_loop = 0;

namespace LED
{
    /**
     * @brief Callback for signal. Called when a signal is recivied to stop the infinite loop
     * 
     * @param signo signal number
     */
    void sig_handler(int signo)
    {
        switch (signo)
        {
        case SIGINT:
            end_loop = 1;
            break;
        default:
            std::cout << "signo: " << signo << " ignored" << std::endl;
            break;
        }
    }

    Ledctrl::Ledctrl() : client(BASE_ADDR, PORT) {}

    Ledctrl::~Ledctrl()
    {
        for (auto &elem : leds)
        {
            delete elem;
        }
    }

    void Ledctrl::init()
    {
        std::string topology;
        rapidjson::Document doc;

        std::signal(SIGINT, sig_handler);

        /* Retrieve DALI bus connected devices */
        if (client.GET(GET_TOPOLOGY, topology) < 0)
        {
            throw std::runtime_error("Failed to get dali topology");
        }

        /** Parse REST server json response and store it in the leds vector 
         *  which will contain all the available LEDs on the DALI bus.
         */
        doc.Parse(topology.c_str());

        assert(doc.IsObject());

        auto top = doc[DATA_OBJ].GetObject();
        auto devices = top[DEVICE_ARR].GetArray();

        for (rapidjson::Value::ConstValueIterator it = devices.Begin(); it != devices.End(); ++it)
        {
            assert(it->IsObject());
            assert(it->HasMember(DEVICE_TYPE));

            if (strcmp((*it)[DEVICE_TYPE].GetString(), DEVICE_LED) == 0)
            {
                led_t *l = new led_t;
                l->id = (*it)[LED_ID].GetInt();

                assert((*it)[LED_STATUS].IsArray());

                auto stat_array = (*it)[LED_STATUS].GetArray();

                /** TODO: change array generated by topology on wago device **/
                l->status = stat_array[1].GetInt();

                leds.push_back(l);
            }
        }
        
        /** sort by ID value, smallest first **/
        std::sort(leds.begin(), leds.end(), [](led_t *a, led_t *b) { return a->id < b->id; });
    }

    void Ledctrl::start_debug()
    {
        int debug_fd;
        char buf[BUFFER_SIZE] = {0};

        if ((debug_fd = open(SYSFS_DEBUG, O_RDWR)) < 0)
        {
            throw std::runtime_error("Failed to open " SYSFS_DEBUG " : " +
                                     std::string(strerror(errno)));
        }

        /** Activate debug thread func **/
        std::cout << "Activating debug mode" << std::endl;
        int dbg;

        if (read(debug_fd, &buf, 1) < 0)
        {
            throw std::runtime_error("Failed to read to " SYSFS_DEBUG " : " +
                                     std::string(strerror(errno)));
        }

        std::cout << "Debug mode: " << std::stoi(buf) << std::endl;

        if (!std::stoi(buf))
        {
            std::cout << "Debug mode not active. Start activation" << std::endl;
            dbg = 1;

            if (write(debug_fd, &dbg, sizeof(int)) < 0)
            {
                throw std::runtime_error("Failed to write to " SYSFS_DEBUG " : " +
                                         std::string(strerror(errno)));
            }
        }

        if (close(debug_fd) < 0)
        {
            throw std::runtime_error("Failed to close " SYSFS_DEBUG " : " +
                                     std::string(strerror(errno)));
        }
    }

    void Ledctrl::stop_debug()
    {
        int debug_fd;
        char buf[BUFFER_SIZE] = {0};

        if ((debug_fd = open(SYSFS_DEBUG, O_RDWR)) < 0)
        {
            throw std::runtime_error("Failed to open " SYSFS_DEBUG " : " +
                                     std::string(strerror(errno)));
        }

        /** Activate debug thread func **/
        std::cout << "Deactivating debug mode" << std::endl;
        int dbg;

        if (read(debug_fd, &buf, 1) < 0)
        {
            throw std::runtime_error("Failed to read to " SYSFS_DEBUG " : " +
                                     std::string(strerror(errno)));
        }

        std::cout << "Debug mode: " << std::stoi(buf) << std::endl;

        if (std::stoi(buf))
        {
            std::cout << "Debug mode is active.Deactivating" << std::endl;
            dbg = 0;

            if (write(debug_fd, &dbg, sizeof(int)) < 0)
            {
                throw std::runtime_error("Failed to write to " SYSFS_DEBUG " : " +
                                         std::string(strerror(errno)));
            }
        }

        if (close(debug_fd) < 0)
        {
            throw std::runtime_error("Failed to close " SYSFS_DEBUG " : " +
                                     std::string(strerror(errno)));
        }
    }

    void Ledctrl::extract_ids(char *ids, std::vector<int> &vect_ids)
    {
        std::stringstream ss(ids);
        int id = 0;

        while (ss.good())
        {
            std::string sub;
            getline(ss, sub, IDS_DELIM);

            if (sub.empty())
                continue;

            try
            {
                id = std::stoi(sub);
            }
            catch (std::invalid_argument e)
            {
                std::cout << "Failed to convert string: " << std::endl;
                for (int i = 0; i < sub.length(); i++)
                {
                    std::cout << std::hex << "[" << i << "]" << (int)sub[i]
                              << std::dec << std::endl;
                }
                continue;
            }

            vect_ids.push_back(id);
        }
    }

    void Ledctrl::process_notify(char *cmd, char *ids)
    {
        wagoled_cmd_t _cmd;
        std::vector<int> _ids;
        bool all_leds = false;

        for (int i = 0; i < CMD_NUM; i++)
        {
            if (strcmp(notify_str[i], cmd) == 0)
            {
                _cmd = (wagoled_cmd_t)i;
                break;
            }
        }

        if (strcmp(ids, LED_ALL) == 0)
            all_leds = true;
        else
            extract_ids(ids, _ids);

#ifdef DEBUG
        std::cout << "selected cmd: " << notify_str[_cmd] << ", ids: " << std::endl;
        for (auto &elem : _ids)
        {
            std::cout << elem;
        }
        std::cout << std::endl;
#endif

        switch (_cmd)
        {
        case CMD_LED_ON:
            /** Turn on LEDs **/
            if (all_leds)
                turn_all_on();
            else
                turn_on(_ids);
            break;

        case CMD_LED_OFF:
            /** Turn off LEDs **/
            if (all_leds)
                turn_all_off();
            else
                turn_off(_ids);
            break;

        case CMD_GET_STATUS:
            /** Update status of LEDs **/
            update_status();
            /** TODO: write status to backend **/
            break;

        case CMD_GET_TOPOLOGY:
            /** TODO: write topology to backend **/
            break;

        default:
            break;
        }
    }

    int Ledctrl::main_loop()
    {
        int notify_fd, attr_fd;
        int rd;
        char cmd[CMD_SIZE] = {0}, attr_path[BUFFER_SIZE] = {0}, ids[BUFFER_SIZE] = {0};

#ifdef DEBUG
        start_debug();
#endif
        while (!end_loop)
        {
            memset(cmd, 0, CMD_SIZE);
            memset(ids, 0, BUFFER_SIZE);
            memset(attr_path, 0, BUFFER_SIZE);

            /** Open sysfs vwagoled_notify **/
            if ((notify_fd = open(SYSFS_NOTIFY, O_RDONLY)) < 0)
            {
                throw std::runtime_error("Failed to open " SYSFS_NOTIFY " : " +
                                         std::string(strerror(errno)));
            }

            /** wait until the backend has something to send */
            if ((rd = read(notify_fd, &cmd, CMD_SIZE)) < 0)
            {
                perror("read()");
                break;
            }

            close(notify_fd);

            sprintf(attr_path, "%s%s", SYSFS_BASE, cmd);

            /** Open the attribute corresponding to the command read in notify */
            if ((attr_fd = open(attr_path, O_RDONLY)) < 0)
            {
                throw std::runtime_error("Failed to open " + std::string(attr_path) + " : " +
                                         std::string(strerror(errno)));
            }

            /** Read the IDs to apply the command to **/
            if ((rd = read(attr_fd, &ids, BUFFER_SIZE)) < 0)
            {
                perror("read()");
                break;
            }
            close(attr_fd);

#ifdef DEBUG
            std::cout << "CMD: " << cmd << ", ids: " << ids << std::endl;
#endif
            /** Process the backend request **/
            process_notify(cmd, ids);
        }

        turn_all_off();

#ifdef DEBUG
        stop_debug();
#endif

        return 0;
    }

    void Ledctrl::build_args_str(std::string &args, std::vector<int> ids)
    {
        args = ARGS;

        std::sort(ids.begin(), ids.end(), [](int i, int j)
                  { return i < j; });

        for (auto &elem : ids)
        {
            if (elem < leds.size() + 1)
            {
                args += std::to_string(elem) + ",";
            }
            else
            {
                std::cout << "Error : id " << elem << " do not exists" << std::endl;
            }
        }
    }

    void Ledctrl::turn_on(std::vector<int> ids)
    {
        std::string args;
        build_args_str(args, ids);

        if (client.POST(POST_LED_ON, args) < 0)
        {
            throw std::runtime_error("Failed to POST led on");
        }
    }

    void Ledctrl::turn_off(std::vector<int> ids)
    {
        std::string args;
        build_args_str(args, ids);

        if (client.POST(POST_LED_OFF, args) < 0)
        {
            throw std::runtime_error("Failed to POST led off");
        }
    }

    void Ledctrl::turn_all_on()
    {
        if (client.POST(POST_LED_ON, ARGS LED_ALL) < 0)
        {
            throw std::runtime_error("Failed to POST led on");
        }
    }

    void Ledctrl::turn_all_off()
    {
        if (client.POST(POST_LED_OFF, ARGS LED_ALL) < 0)
        {
            throw std::runtime_error("Failed to POST led off");
        }
    }

    void Ledctrl::update_status()
    {
        std::string resp;
        rapidjson::Document doc;
        int id;

        if (client.GET(GET_STATUS, resp, ARGS LED_ALL) < 0)
        {
            throw std::runtime_error("Failed to GET status");
        }

        doc.Parse(resp.c_str());

        assert(doc.IsObject());

        auto top = doc[DATA_OBJ].GetObject();
        auto devices = top[LEDS_ARRAY].GetArray();

        for (rapidjson::Value::ConstValueIterator it = devices.Begin(); it != devices.End(); ++it)
        {
            assert(it->IsObject());
            assert(it->HasMember(LED_ID));
            assert(it->HasMember(LED_STATUS));

            /** Update led status **/
            leds[(*it)[LED_ID].GetInt()]->status = (*it)[LED_STATUS].GetInt();
        }
    }

} // end LED