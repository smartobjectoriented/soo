#include <rapidjson/document.h>
#include <iostream>
#include <stdexcept>
#include <algorithm> 
#include <unistd.h>
#include <fcntl.h>
#include <csignal>
#include <cerrno>
#include <string>
#include <cstring>
#include <cstdio>
#include <sstream>

#include "ledcontrol.h"

#if 0
#define DEBUG
#endif

sig_atomic_t end_loop = 0;

namespace LED
{
    void sig_handler(int signo)
    {
       switch(signo)
       {
            case SIGINT:
                end_loop = 1;
                break;
            default:
                std::cout << "signo: " << signo << " ignored" << std::endl;
                break;
       }
    }

    Ledctrl::Ledctrl() : client(BASE_ADDR, PORT) {}

    Ledctrl::~Ledctrl()
    {
        for(auto& elem : leds)
        {
            delete elem;
        }
    }

    void Ledctrl::init()
    {
        std::string topology;
        rapidjson::Document doc;

        std::signal(SIGINT, sig_handler);

        if (client.GET(GET_TOPOLOGY, topology) < 0) 
        {
            throw std::runtime_error("Failed to get dali topology");
        }

        doc.Parse(topology.c_str());

        assert(doc.IsObject());

        auto top = doc[DATA_OBJ].GetObject();
        auto devices = top[DEVICE_ARR].GetArray();

        for (rapidjson::Value::ConstValueIterator it = devices.Begin(); it != devices.End(); ++it)
        {
            assert(it->IsObject());
            assert(it->HasMember(DEVICE_TYPE));

            if (strcmp((*it)[DEVICE_TYPE].GetString(), DEVICE_LED) == 0)
            {
                led_t *l = new led_t;
                l->id = (*it)[LED_ID].GetInt();
                
                assert((*it)[LED_STATUS].IsArray());

                auto stat_array = (*it)[LED_STATUS].GetArray();

                //TODO change array generated by topology on wago device
                l->status = stat_array[1].GetInt();

                leds.push_back(l);
            }
        }
    }

    void Ledctrl::start_debug()
    {
        int debug_fd;
        char buf[BUFFER_SIZE] = {0};

        if ((debug_fd = open(SYSFS_DEBUG, O_RDWR)) < 0)
        {
            throw std::runtime_error("Failed to open " SYSFS_DEBUG " : " + 
                                        std::string(strerror(errno)));
        }

        //Activate debug thread func
        std::cout << "Activating debug mode" << std::endl;
        int dbg;

        if (read(debug_fd, &buf, 1) < 0)
        {
            throw std::runtime_error("Failed to read to " SYSFS_DEBUG " : " + 
                                        std::string(strerror(errno)));
        }

        std::cout << "Debug mode: " << std::stoi(buf) << std::endl;

        if (!std::stoi(buf))
        {
            std::cout << "Debug mode not active. Start activation" << std::endl;
            dbg = 1;

            if (write(debug_fd, &dbg, sizeof(int)) < 0)
            {
                throw std::runtime_error("Failed to write to " SYSFS_DEBUG " : " + 
                                            std::string(strerror(errno)));
            }
        }

        if (close(debug_fd) < 0)
        {
            throw std::runtime_error("Failed to close " SYSFS_DEBUG " : " + 
                                        std::string(strerror(errno)));
        }
    }

    void Ledctrl::stop_debug()
    {
        int debug_fd;
        char buf[BUFFER_SIZE] = {0};

        if ((debug_fd = open(SYSFS_DEBUG, O_RDWR)) < 0)
        {
            throw std::runtime_error("Failed to open " SYSFS_DEBUG " : " + 
                                        std::string(strerror(errno)));
        }

        //Activate debug thread func
        std::cout << "Deactivating debug mode" << std::endl;
        int dbg;

        if (read(debug_fd, &buf, 1) < 0)
        {
            throw std::runtime_error("Failed to read to " SYSFS_DEBUG " : " + 
                                        std::string(strerror(errno)));
        }

        std::cout << "Debug mode: " << std::stoi(buf) << std::endl;

        if (std::stoi(buf))
        {
            std::cout << "Debug mode is active.Deactivating" << std::endl;
            dbg = 0;

            if (write(debug_fd, &dbg, sizeof(int)) < 0)
            {
                throw std::runtime_error("Failed to write to " SYSFS_DEBUG " : " + 
                                            std::string(strerror(errno)));
            }
        }

        if (close(debug_fd) < 0)
        {
            throw std::runtime_error("Failed to close " SYSFS_DEBUG " : " + 
                                        std::string(strerror(errno)));
        }
    }

    void Ledctrl::extract_ids(char *ids, std::vector<int>& vect_ids)
    {
        std::stringstream ss(ids);
        int id = 0;

        while(ss.good())
        {
            std::string sub;
            getline(ss, sub, IDS_DELIM);

            if (sub.empty())
                continue;

            try 
            {
                id = std::stoi(sub);
            }
            catch(std::invalid_argument e)
            {
                std::cout << "Failed to convert string: " << std::endl;
                for (int i = 0; i < sub.length(); i++)
                {
                    std::cout << std::hex << "[" << i << "]" << (int)sub[i] 
                                << std::dec << std::endl;
                }
                continue;
            }

            vect_ids.push_back(id);
        }

    }

    int Ledctrl::process_notify(char *cmd, char* ids)
    {
        wagoled_cmd_t _cmd;
        std::vector<int> _ids;

        for (int i = 0; i < CMD_NUM; i++)
        {
            if (strcmp(notify_str[i], cmd) == 0)
            {
                _cmd = (wagoled_cmd_t)i;
                break;
            }
        }

        extract_ids(ids, _ids);

#ifdef DEBUG
        std::cout << "selected cmd: " << notify_str[_cmd] << ", ids: " <<std::endl;
        for (auto &elem : _ids)
        {
            std::cout << elem;
        }
        std::cout << std::endl;
#endif

        switch (_cmd)
        {
        case CMD_LED_ON:
            //call turn_on
            turn_on(_ids);
            break;
        
        case CMD_LED_OFF:
            //call turn_off
            turn_off(_ids);
            break;

        case CMD_GET_STATUS:
            //call get_status
            update_status();
            break;

        case CMD_GET_TOPOLOGY:
            //call get_topology
            break;
        
        default:
            break;
        }

        return 0;
    }

    int Ledctrl::main_loop()
    {
        int notify_fd, attr_fd;
        int rd;
        char cmd[CMD_SIZE] = {0}, attr_path[BUFFER_SIZE] = {0}, ids[BUFFER_SIZE] = {0};

#ifdef DEBUG
        start_debug();
#endif
        while(!end_loop)
        {
            memset(cmd, 0, CMD_SIZE);
            memset(ids, 0, BUFFER_SIZE);
            memset(attr_path, 0, BUFFER_SIZE);

            if ((notify_fd = open(SYSFS_NOTIFY, O_RDONLY))  < 0)
            {
                throw std::runtime_error("Failed to open " SYSFS_NOTIFY " : " + 
                                            std::string(strerror(errno)));
            }
            
            if ((rd = read(notify_fd, &cmd, CMD_SIZE)) < 0)
            {
                perror("read()");
                break;
            }

            close(notify_fd);

            sprintf(attr_path, "%s%s", SYSFS_BASE, cmd);

            if ((attr_fd = open(attr_path, O_RDONLY)) < 0)
            {
                throw std::runtime_error("Failed to open " + std::string(attr_path) + " : " + 
                                            std::string(strerror(errno)));
            }

            if ((rd = read(attr_fd, &ids, BUFFER_SIZE)) < 0)
            {
                perror("read()");
                break;
            }
            close(attr_fd);

#ifdef DEBUG
            std::cout << "CMD: "<< cmd << ", ids: " << ids << std::endl;
#endif
            process_notify(cmd, ids);
        }

        turn_all_off();

#ifdef DEBUG
        stop_debug();
#endif

        return 0;
    }

    void Ledctrl::build_args_str(std::string& args, std::vector<int> ids)
    {
        args = ARGS;

        std::sort(ids.begin(), ids.end(), [](int i, int j) { return i < j; });

        for (auto& elem : ids)
        {
            if (elem < leds.size() + 1) 
            {
                args += std::to_string(elem) + ",";
            } 
            else
            {
                std::cout << "Error : id " << elem << " do not exists" << std::endl;
            }
        }
    }

    int Ledctrl::turn_on(std::vector<int> ids)
    {
        std::string args;
        build_args_str(args, ids);

        if (client.POST(POST_LED_ON, args) < 0) 
        {
            std::cout << "Failed to POST led on" << std::endl;
            return -1;
        }

        return 0;
    }

    int Ledctrl::turn_off(std::vector<int> ids)
    {
        std::string args;
        build_args_str(args, ids);

        if (client.POST(POST_LED_OFF, args) < 0) 
        {
            std::cout << "Failed to POST led off" << std::endl;
            return -1;
        }

        return 0;
    }

    int Ledctrl::turn_all_on()
    {
        if (client.POST(POST_LED_ON, ARGS LED_ALL) < 0) 
        {
            std::cout << "Failed to POST led on" << std::endl;
            return -1;
        }

        return 0;
    }

    int Ledctrl::turn_all_off()
    {
        if (client.POST(POST_LED_OFF, ARGS LED_ALL) < 0) 
        {
            std::cout << "Failed to POST led off" << std::endl;
            return -1;
        }

        return 0;
    }

    void Ledctrl::update_status()
    {
        std::string resp;

        if (client.GET(GET_STATUS, resp, ARGS LED_ALL) < 0) {
            std::cout << "Failed to read status" << std::endl;
        } else {
            std::cout << "get status :\n" << resp << std::endl;
        }
    }

} //end LED